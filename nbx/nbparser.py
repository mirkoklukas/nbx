# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/05_nbparser.ipynb.

# %% auto 0
__all__ = ['tag_rx', 'flagname_rx', 'xarg_rx', 'PARSER_DICT', 'is_nbx', 'magic_shell_rx', 'XARG_MISSING', 'TEMPLATE_PATH',
           'load_nb', 'parse_any_tag', 'parse_tag', 'result_or_none', 'flagname', 'parse_flagname', 'parse_nbx_meta',
           'strip', 'strip_or_none', 'strip_dict_vals', 'parse_xarg', 'parse_default', 'consume_line', 'consume_block',
           'ignore_first', 'consume_line_below', 'consume_block_below', 'parse_src', 'parse_cell', 'is_none',
           'is_not_none', 'is_tagged', 'is_nbx_cell', 'is_magic_or_shell', 'move_to_front', 'parse_nb',
           'add_if_necessary', 'create_script', 'create_experiment', 'create_confspace', 'create_wrapper',
           'create_runner', 'create_bundle']

# %% ../notebooks/05_nbparser.ipynb 4
from typing import Union, List, Tuple
from .utils import listmap
import ipynbname
import json
from .utils import Bunch
from pathlib import Path

# %% ../notebooks/05_nbparser.ipynb 5
def load_nb(fname):
    """Loads a a ipynotebook-bunch""" 
    try:
        nbdict = json.loads(fname)
    except:
        nbdict = json.load(open(fname,'r',encoding="utf-8"))
        
    nbdict["fname"] = str(fname)
    return Bunch(**nbdict)

# %% ../notebooks/05_nbparser.ipynb 10
import re
tag_rx = re.compile(r"^\s*#([a-zA-Z_]+)\s*(.*)$")

def parse_any_tag(line):
    """
    Splits off a tag (eg. `#MyTAg`) at the beginning of the line. 
    """
    m = tag_rx.match(line)
    if m is not None: return m.groups()
    else: return None

# %% ../notebooks/05_nbparser.ipynb 12
def parse_tag(name):
    """Splits off a specified tag only"""

    def p(line):
        r = parse_any_tag(line)
        if r is None or r[0] != name: return None
        else: return r
    return p

# %% ../notebooks/05_nbparser.ipynb 14
def result_or_none(y:"returned object by a parser"):
    if y is None: return None
    else: return y[0]

# %% ../notebooks/05_nbparser.ipynb 22
import re
# flag_rx =     re.compile(r"(?:[\-]+)(?P<name>[a-zA-Z_\-]+)=?(.*)$")
flagname_rx = re.compile(r"(?:[\-]+)(?P<name>[a-zA-Z_\-]+)=?(.*)?$")
def flagname(line):
    """
    Splits off the name of a flag `--flagename`. 
    """
    m = flagname_rx.match(line)
    if m is not None: return m.groups()[0]
    else: return None
    
# def is_flag(line): return flagname(line) is not None

# def pairs(arr):
#     n = len(arr); 
#     assert n%2==0
#     ps = []
#     for i in range(n//2): ps.append((arr[2*i],arr[2*i+1]))
#     return ps

# %% ../notebooks/05_nbparser.ipynb 25
import re
flagname_rx = re.compile(r"(?:[\-]+)(?P<name>[a-zA-Z_\-]+)=?(.*)?$")

def parse_flagname(line):
    m = flagname_rx.match(line)
    if m is not None: 
        n,r = m.groups()
        if r is None: r = ""
        return (n,r)
    else: return None

# %% ../notebooks/05_nbparser.ipynb 33
import shlex
def parse_nbx_meta(line):    
    _, r = parse_tag("nbx_meta")(line)
    try:
        f, r = parse_flags(r)
        f["tag"] = "nbx_meta"
    except: return None
    return (f,r)


# %% ../notebooks/05_nbparser.ipynb 38
xarg_rx = re.compile(r"""
^(?P<name>[^=]+)=(?P<val>[^;#]+)
(?:(?:;(?P<sweep>[^\#]*))?(?:\#(?P<help>.*))?)?
$""", re.VERBOSE)

def strip(s):
    return s.strip()

def strip_or_none(s):
    if s is None: return None
    else: return s.strip()

def strip_dict_vals(d):
    for k,v in d.items():
        d[k] = strip_or_none(v)
    return d
    
def parse_xarg(line):
    """
    Parses the line below an `xarg` tag and
    returns a dict with keys `[name,val,type,help,sweep]`.
    """

    m = xarg_rx.match(line)
    if m is None: return None
    
    d = dict(**m.groupdict())
    d = strip_dict_vals(d)
    
    v = eval(d['val'])
    d['type'] = type(v).__name__ 
    
    if d['help']  == "": d['help']  = None
    if d['sweep'] == "": d['sweep'] = None
    
    return (d, "")


# %% ../notebooks/05_nbparser.ipynb 42
def parse_default(line):
    return (line.rstrip(), "")

# %% ../notebooks/05_nbparser.ipynb 43
def consume_line(tag, p = parse_default):
    """
    Returns a parser that 
    consume a line and parses it.
    """
    
    def q(a, src):
        if len(src) == 0: return a, []
        line = src[0]
        
        b = result_or_none(p(line))
        
        a.append((tag, line, b))
        return a, src[1:]
    
    return q

# %% ../notebooks/05_nbparser.ipynb 44
def consume_block(tag, p = parse_default):
    """
    Returns a parser that consume a block of lines 
    and parse them, till you hit an empty line, 
    a comment/tag, or the end.
    """
    
    def parse(a, src):
        if len(src) == 0: return a, []
        
        line = src[0]
        
        # stopping conditions
        if line.strip() == "": return a, src
        if line.strip()[0] == "#":  return a, src
        
        # else consume line
        b = result_or_none(p(line))        
        a.append((tag, line, b))

                 
        return parse(a, src[1:])
                 
    return parse



# %% ../notebooks/05_nbparser.ipynb 45
def ignore_first(p):
    """
    Return a parser that ignores the first line and 
    starts parsing starting at the next.
    """
    def q(a, src):
        if len(src) <= 1: return a, []
        else: return p(a, src[1:])
    return q


# %% ../notebooks/05_nbparser.ipynb 46
def consume_line_below(tag, p = parse_default):
    return ignore_first(consume_line(tag, p=p))

def consume_block_below(tag, p = parse_default):
    return ignore_first(consume_block(tag, p=p))

# %% ../notebooks/05_nbparser.ipynb 47
def parse_src(a:list, src:list, parser_dict: dict, parse_default=parse_default):
    """Parses a cell sources..."""
    if len(src) == 0: return a, []
    
    line = src[0]
    
    tag = result_or_none(parse_any_tag(line))
    
    if tag is None or tag not in parser_dict:
        b, _ = parse_default(line)
        a.append((None, line, b))
        rest = src[1:]
    else:        
        p = parser_dict[tag]
        a, rest = p(a, src)

    return parse_src(a, rest, parser_dict)

# %% ../notebooks/05_nbparser.ipynb 48
PARSER_DICT = {
    'nbx'       : consume_line('nbx'),
    'nbx_meta'  : consume_line('nbx_meta', parse_nbx_meta),
    'nbx_return': consume_line_below("nbx_return"), 
    'xarg' : consume_block_below('xarg', parse_xarg),
    'xargs': consume_block_below('xarg', parse_xarg),
    'ximp' : consume_block_below('ximp'),
    'ximps': consume_block_below('ximps')}

def parse_cell(cell, parser_dict=PARSER_DICT):
    src = listmap(lambda line: line.rstrip(), cell['source'])
    a, _ = parse_src([], src, parser_dict)
    return a

# %% ../notebooks/05_nbparser.ipynb 51
def is_none(x): return x is None
def is_not_none(x): return x is not None
def is_tagged(name):
    return lambda line: is_not_none(parse_tag(name)(line))
is_nbx = is_tagged("nbx")

# %% ../notebooks/05_nbparser.ipynb 53
def is_nbx_cell(cell):
    if cell['cell_type'] != 'code': return False
    if not cell['source']: return False
    line0 = cell['source'][0]
    return is_nbx(line0)

# %% ../notebooks/05_nbparser.ipynb 54
magic_shell_rx =  re.compile(r"^\s*%{1,2}|^\s*!")

def is_magic_or_shell(line):
    """Checks if line contains a jupyter 
    magic function or shell command"""
    m = magic_shell_rx.match(line)
    return m is not None

# %% ../notebooks/05_nbparser.ipynb 56
from collections import defaultdict

def move_to_front(arr, i):
    return [arr[i]] + arr[:i] + arr[i+1:]
    
XARG_MISSING = """
        
#xargs
xtask = 0
xdir  = './'

"""

def parse_nb(nb, parser_dict=PARSER_DICT):
    """Parses a notebook bunch"""
    
    # Parse all of the `nbx` cells
    nbx_cells = filter(is_nbx_cell, nb.cells)
    A = defaultdict(list)
    for cell in nbx_cells:
        a = parse_cell(cell, parser_dict=PARSER_DICT)

        for t, line, b in a:
            if t is None: t = 'func_body'
            A[t].append(b)
        
    # Make sure xtask and xdir are present
    argdict = {}
    for i,x in enumerate(A["xarg"]): argdict[x['name']] = i
    if "xdir" not in argdict or "xtask" not in argdict:
        raise NameError("YOU NEED TO ADD X-ARGS `xdir` and `xtask`(see below):..."+XARG_MISSING)
    move_to_front(A["xarg"], argdict["xdir"])
    move_to_front(A["xarg"], argdict["xtask"])
    
    # Parameter sweeps
    A["sweep"]     = []
    A["non_sweep"] = []
    for x in A["xarg"]:
        if x["sweep"] is None: 
            A["non_sweep"].append(x)
        else: 
            A["sweep"].append(x)
            
        
    # Meta data  
    if "nbx_meta" in A: A["nbx_meta"] = A["nbx_meta"][0]
    else: A["nbx_meta"] = {}
    A["nbx_meta"]["nbname"] = nb["fname"]
            
    # Set the return value
    if "nbx_return" in A:
        A["nbx_return"] = A["nbx_return"][-1]

    return Bunch(**A)

# %% ../notebooks/05_nbparser.ipynb 60
from pathlib import PurePosixPath as Path
import pkg_resources
import importlib
from .utils import nbx_lib
from .templ import *
import os

def add_if_necessary(d, k, v):
    if k not in d:
        d[k] = v
        
TEMPLATE_PATH = Path("/Users/mirko/Workspace/nbx/notebooks/nbx_example/templates")
TEMPLATE_PATH 

# %% ../notebooks/05_nbparser.ipynb 61
def create_script(fname, tpl, vdict={}):
    """Create script from template and value dict""" 
    return create_file_from_template(TEMPLATE_PATH/tpl, fname, vdict)

# %% ../notebooks/05_nbparser.ipynb 63
def create_experiment(pnb, fname="experiment.py", tpl="experiment.tpl"):
    return create_script(fname, tpl, pnb)

# %% ../notebooks/05_nbparser.ipynb 65
from .fileio import dump, load

def create_confspace(pnb, fname="confspace.json"):
    meta = {"nbname": str(pnb["nbx_meta"]["nbname"])}
    C = dict(info=meta, src=dict(), default_src=dict())
    default = {}
    for x in pnb["xarg"]:
        key, val, sweep = x["name"], x["val"], x["sweep"]
        C["default_src"][key] = val
        if sweep is None: sweep = f"[{val}]"
        C["src"][key] = sweep
    dump(C, str(fname))
    
    return C

# %% ../notebooks/05_nbparser.ipynb 67
def create_wrapper(pnb, 
                   fname = "wrapper.py", 
                   xname = "experiment.py", 
                   confspace = "confspace.json", 
                   tpl = "wrapper.tpl"):
    
    stem = Path(xname).stem
    return create_script(fname, tpl, 
                         vdict = dict(module=stem, confspace=confspace))

# %% ../notebooks/05_nbparser.ipynb 69
def create_runner(fname="runner.sh", wrapper="wrapper.py", tpl="run.tpl"):
    return create_script(fname, tpl, vdict=dict(wrapper=wrapper))

# %% ../notebooks/05_nbparser.ipynb 71
import shutil
from .utils import run_bash
from importlib import import_module
import sys

def create_bundle(xdir, nbpath=None):
    """
    Creates a nbx-bundle at the given directory
    from a notebook.
    
    The notebook is either specified by its path, or 
    in case of "None" created from the notebook 
    the function is called from.
    """
    
    if not os.path.exists(xdir): os.makedirs(xdir)
    if nbpath is None: nbpath = ipynbname.path()
    xdir, nbpath = Path(xdir), Path(nbpath)
    
    pnb = parse_nb(load_nb(nbpath))

    create_script(xdir/"__init__.py", "init.tpl", vdict={})
    create_experiment(pnb, fname=xdir/"experiment.py", tpl="experiment.tpl")
    create_confspace( pnb, fname=xdir/"confspace.json")
    create_wrapper(   pnb, fname=xdir/"wrapper.py", xname="experiment.py", confspace="confspace.json", tpl="wrapper.tpl")
    create_runner(fname=xdir/"runner.sh", wrapper="wrapper.py", tpl="run.tpl")
    
    # Btw: -B suppresses the creation of __pycache__
    num_confs, = run_bash(f"python -B {xdir/'wrapper.py'} info")
    num_confs = int(num_confs.strip())

    print(pnb["nbx_meta"])
    print(f"Creating bundle:\n")
    if "src" in pnb["nbx_meta"]:
        xsrc = pnb["nbx_meta"]["src"]
        if os.path.exists(nbpath.parent/xsrc): 
            print(f"\t{xdir/xsrc/'*'}")  
            
            if os.path.exists(str(xdir/xsrc)): 
                shutil.rmtree(str(xdir/xsrc))    
                
            shutil.copytree(str(nbpath.parent/xsrc), str(xdir/xsrc))
            
            
    print(f"\t{xdir/'experiment'}")    
    print(f"\t{xdir/'confspace.json'} (#confs = {num_confs})")
    print(f"\t{xdir/'wrapper.py'}")
    print(f"\t{xdir/'runner.sh'}\n")
    

