# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/06_new_parser.ipynb.

# %% auto 0
__all__ = ['fail', 'item', 'seed', 'tag_rx', 'p', 'flagname_rx', 'parse_tagged_line', 'is_nbx', 'Parser', 'result',
           'result_or_none', 'seq', 'compr', 'many', 'many1', 'parse_any_tag', 'rx_parser', 'parse_flagname',
           'starts_with_flag', 'parse_flags', 'load_nb', 'is_nbx_cell', 'get_nbx_cells', 'Line', 'TaggedLine',
           'EmptyLine', 'tokenize_lines', 'parse_nb']

# %% ../notebooks/06_new_parser.ipynb 3
from collections import defaultdict


class Parser(object):
    """
    For us a parser is a callable with signature
    ```
        String -> (a, String) or None
    ```
    where `a` is the parser result.
    Bindable functions have the signature 
    ```
        a -> Parser a
    ```
    """
    def __init__(self, f = lambda line: (None, line)): 
        """Wraps a fn with signitaure `line -> (a, line)` into a parser."""
        self.func = f
        
        
    def __call__(self, line): 
        return self.func(line)
    

    def bind(self, f): 
        """Monadic bind. Binds functions `a -> Parser a`"""
        def q(line):
            """The new parser func."""
            try: b, rest = self(line)
            except: return None
            return f(b)(rest)
        
        return Parser(q)
    
    
    def __rshift__(self, f):
        return self.bind(f)
    
    
    def __or__(self, q):
        """If `Self` fails try `q`."""
        def p(line):
            try: 
                a,rest = self(line)
                return (a, rest)
            except:
                return q(line)
            
        return Parser(p)
    
    
    def __eq__(self, val):
        """Checks if result equals a given value."""
        def check(a, val):
            if isinstance(val, dict):
                for k, v in val.items(): 
                    if a[k] != v: return False
                return True
            else:
                return a == val

        return self.bind(lambda a: result(a) if check(a, val) else fail)
    
    
    def __ne__(self, val):
        """Checks if result does not equal a given value."""
        def check(a, val):
            if isinstance(val, dict):
                equal = True
                for k, v in val.items(): 
                    if a[k] != v: return True
            else:
                return a != val

        return self.bind(lambda a: result(a) if check(a, val) else fail)
    
        
    def __matmul__(self, key):      
        """
        Returns a bindable function `f(a)` that applies 
        the parser `self` and updates the given result dict `a` 
        with `self`'s results.
        """                
        def f(a):
            def p(line):
                try: b, rest = self(line)
                except: return None
                if key is None: return (a, rest)
                a[key] = b
                return (a, rest)
            
            return p
            
        return f
         

# A couple of useful atomic parsers 
def result(a): return Parser(lambda line: (a, line))
fail = Parser(lambda line: None)
item = Parser(lambda line: (line[0], line[1:]) if len(line)>0 else None)
seed = Parser(lambda line: ({}, line))

# %% ../notebooks/06_new_parser.ipynb 4
def result_or_none(y:"parser return"):
    """Returns None or the parser result (without the rest)."""
    if y is None: return None
    else: return y[0]

# %% ../notebooks/06_new_parser.ipynb 5
def seq(p, q): 
    return p >> (lambda a: (q >> (lambda b: result([a, b]))))

def compr(*ps, f = lambda *x: list(x)):
    def q(line):
        A = []
        rest = line
        for p in ps:
            try: a, rest = p(rest)
            except: return None
            A.append(a)
        return f(*A), rest
    return Parser(q)

# %% ../notebooks/06_new_parser.ipynb 7
def many(q):
    """Apply `q` ZERO or MORE times."""
    def wrapper(line):
        a = []
        def p(line):
            if len(line) == 0: return (a, line)
            try: b, rest = q(line)
            except: return (a, line)
            a.append(b)
            return p(rest)
        
        return p(line)
    return Parser(wrapper)


def many1(q):
    """Apply `q` ONE or MORE times."""
    def p(line):
        try: a, rest_ = q(line)
        except: return None
        b, rest = many(q)(rest_)
        
        return ([a] + b,rest) 

    return Parser(p)

# %% ../notebooks/06_new_parser.ipynb 11
import re
tag_rx = re.compile(r"^\s*#([a-zA-Z_]+)\s*(.*)$")

@Parser
def parse_any_tag(line):
    """
    Splits off a tag (eg. `#MyTAg`) 
    at the beginning of the line. 
    """
    m = tag_rx.match(line)
    if m is not None: return m.groups()
    else: return None

# %% ../notebooks/06_new_parser.ipynb 14
def rx_parser(rx):
    def p(line):
        m = rx.match(line)
        if m is not None: 
            d = m.groupdict()
            return (d, d.pop("rest", ""))
        else: return None
        
    return Parser(p)
        
    
p = rx_parser(re.compile(r"^\s*(#)(?P<tag>[a-zA-Z_]+)\s*(?P<rest>.*)$"))
p("#hi my name is")

# %% ../notebooks/06_new_parser.ipynb 16
import re
flagname_rx = re.compile(r"\s*(?:[\-]+)(?P<name>[a-zA-Z_\-]+)=?(.*)?$")

def parse_flagname(line):
    """
    Splits off the name of a flag iff 
    there is one at the beginning.
    """
    m = flagname_rx.match(line)
    if m is not None: 
        n,r = m.groups()
        if r is None: r = ""
        return (n,r.lstrip())
    else: return None
    
def starts_with_flag(line): return parse_flagname(line) is not None

# %% ../notebooks/06_new_parser.ipynb 18
from collections import defaultdict
import shlex 

@Parser
def parse_flags(line):
    d    = dict()
    last = None
    rest = [] # not a flag-key nor a value 
    for s in shlex.split(line):
        try:
            n, v = parse_flagname(s)
            if n not in d: d[n] = []
            if v != "": d[n].append(v.strip())
            last = None
        except: 
            if last is not None: d[last].append(s.strip())
            else: rest.append(s)
            last = None
    return (d, rest)

parse_tagged_line = seq(parse_any_tag, parse_flags)

# %% ../notebooks/06_new_parser.ipynb 21
from typing import Union, List, Tuple
from .utils import listmap
import ipynbname
import json
from .utils import Bunch
from pathlib import Path

# %% ../notebooks/06_new_parser.ipynb 22
def load_nb(fname):
    """Loads a a ipynotebook-bunch""" 
    try:
        nbdict = json.loads(fname)
    except:
        nbdict = json.load(open(fname,'r',encoding="utf-8"))
        
    nbdict["fname"] = str(fname)
    return Bunch(**nbdict)

# %% ../notebooks/06_new_parser.ipynb 24
is_nbx = parse_any_tag == "nbx"

def is_nbx_cell(cell):
    """Checks first of cell source for nbx tag."""
    if cell['cell_type'] != 'code': return False
    if not cell['source']: return False
    line0 = cell['source'][0]
    return is_nbx(line0)


def get_nbx_cells(nb):
    return list(filter(is_nbx_cell, nb.cells))

# %% ../notebooks/06_new_parser.ipynb 27
class Line(object):
    def __init__(self, src=""):
        self.name = None
        self.src  = src
        
    def __eq__(self, other): return self.name == other
    def __ne__(self, other): return self.name != other
    def __str__(self): return f"'{self.src}'"
    def __repr__(self): return f"Line('{self.src}')"
    
    
class TaggedLine(Line):
    def __init__(self, name, src = ""): 
        super().__init__(src=src)
        self.name = name
        
    def __str__(self): return f"<{self.name}/>"
    def __repr__(self): return f"TaggedLine('{self.name}', '{self.src}')"
    
    
class EmptyLine(Line): 
    def __init__(self,): 
        super().__init__(src="")
        self.name = "empty"

# %% ../notebooks/06_new_parser.ipynb 29
def tokenize_lines(src, tags=None):
    parsed = []
    for line in src:
        line = line.rstrip()
        try: 
            tag, _ = parse_any_tag(line.rstrip())
            
            if tags is None:
                parsed.append(TaggedLine(tag, line))
            else:
                if tag in tags:
                    parsed.append(TaggedLine(tag, line))
                else:
                    parsed.append(Line(line))

        except: 
            if line.strip() == "": parsed.append(EmptyLine())
            else: parsed.append(Line(line))
            
    return parsed

# %% ../notebooks/06_new_parser.ipynb 33
def parse_nb(path):
    nb = load_nb(path)
    nb.cells[0]
    lines = []
    for cell in nb.cells:
        parsed = tokenize_lines(cell["source"], tags={"nbx"})
        
        if len(parsed) > 0 and parsed[0] == "nbx": 
            print(parse_tagged_line(parsed[0].src)[0])
            lines.extend([line.src for line in parsed[1:]])
    return lines
    
parse_nb("nbx_example/test_notebook.ipynb")
